AWSTemplateFormatVersion: '2010-09-09'
Description: 'Foom.ist - Human vs Silicon MIPS Crossover visualization'

Parameters:
  DomainName:
    Type: String
    Default: foom.ist
    Description: Domain name for the site

  CertificateArn:
    Type: String
    Description: ARN of ACM certificate in us-east-1

  HostedZoneId:
    Type: String
    Description: Route 53 Hosted Zone ID for the domain

  GitHubOwner:
    Type: String
    Default: StefanSamne
    Description: GitHub repository owner

  GitHubRepo:
    Type: String
    Default: foomist
    Description: GitHub repository name

Resources:
  # ============================================
  # S3 BUCKET FOR STATIC SITE
  # ============================================
  SiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref DomainName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Project
          Value: foomist

  SiteBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SiteBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontOAC
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${SiteBucket.Arn}/*'
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'

  # ============================================
  # CLOUDFRONT DISTRIBUTION
  # ============================================
  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${DomainName}-oac'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        Aliases:
          - !Ref DomainName
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt SiteBucket.RegionalDomainName
            OriginAccessControlId: !Ref CloudFrontOAC
            S3OriginConfig:
              OriginAccessIdentity: ''
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          Compress: true
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # CachingOptimized
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021
        PriceClass: PriceClass_100
      Tags:
        - Key: Project
          Value: foomist

  # ============================================
  # ADMIN PASSWORD SECRET
  # ============================================
  AdminPasswordSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: foomist/admin-password
      Description: 'Admin password for Foom.ist analytics dashboard'
      GenerateSecretString:
        SecretStringTemplate: '{}'
        GenerateStringKey: 'password'
        PasswordLength: 20
        ExcludeCharacters: '"@/\'

  # ============================================
  # ANALYTICS DYNAMODB TABLE
  # ============================================
  AnalyticsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: foomist-analytics
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: visitorId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
        - AttributeName: createdDate
          AttributeType: S
        - AttributeName: sessionId
          AttributeType: S
      KeySchema:
        - AttributeName: visitorId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: DateIndex
          KeySchema:
            - AttributeName: createdDate
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: SessionIndex
          KeySchema:
            - AttributeName: sessionId
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: expiresAt
        Enabled: true
      Tags:
        - Key: Project
          Value: foomist

  # ============================================
  # LAMBDA EXECUTION ROLE
  # ============================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: foomist-lambda-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: FoomistLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:foomist/*'
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:BatchWriteItem
                Resource:
                  - !GetAtt AnalyticsTable.Arn
                  - !Sub '${AnalyticsTable.Arn}/index/*'

  # ============================================
  # MAIN LAMBDA FUNCTION
  # ============================================
  CreateIssueLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: foomist-api
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          GITHUB_OWNER: !Ref GitHubOwner
          GITHUB_REPO: !Ref GitHubRepo
          ANALYTICS_TABLE: !Ref AnalyticsTable
          ADMIN_SECRET_NAME: foomist/admin-password
          GITHUB_SECRET_NAME: foomist/github-token
          DOMAIN: !Ref DomainName
      Code:
        ZipFile: |
          import json
          import boto3
          import hashlib
          import hmac
          import time
          import uuid
          import urllib.request
          from datetime import datetime, timedelta
          from decimal import Decimal

          secrets = boto3.client('secretsmanager')
          dynamodb = boto3.resource('dynamodb')

          import os
          TABLE_NAME = os.environ.get('ANALYTICS_TABLE', 'foomist-analytics')
          ADMIN_SECRET = os.environ.get('ADMIN_SECRET_NAME', 'foomist/admin-password')
          GITHUB_SECRET = os.environ.get('GITHUB_SECRET_NAME', 'foomist/github-token')
          DOMAIN = os.environ.get('DOMAIN', 'foom.ist')

          # Cache secrets
          _admin_password = None
          _github_token = None

          def get_admin_password():
              global _admin_password
              if not _admin_password:
                  resp = secrets.get_secret_value(SecretId=ADMIN_SECRET)
                  _admin_password = json.loads(resp['SecretString'])['password']
              return _admin_password

          def get_github_token():
              global _github_token
              if not _github_token:
                  resp = secrets.get_secret_value(SecretId=GITHUB_SECRET)
                  _github_token = json.loads(resp['SecretString'])['GITHUB_TOKEN']
              return _github_token

          def create_admin_token(password, remember_me=False):
              if password != get_admin_password():
                  return None
              if remember_me:
                  expiry = int(time.time()) + 86400 * 365  # 1 year
              else:
                  expiry = int(time.time()) + 86400  # 24 hours
              message = f"{password}:{expiry}"
              signature = hmac.new(password.encode(), message.encode(), hashlib.sha256).hexdigest()
              return f"{expiry}:{signature}"

          def verify_admin_token(token):
              try:
                  expiry, signature = token.split(':')
                  if int(expiry) < int(time.time()):
                      return False
                  password = get_admin_password()
                  message = f"{password}:{expiry}"
                  expected = hmac.new(password.encode(), message.encode(), hashlib.sha256).hexdigest()
                  return hmac.compare_digest(signature, expected)
              except:
                  return False

          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super().default(obj)

          def handler(event, context):
              path = event.get('rawPath', '/')
              method = event.get('requestContext', {}).get('http', {}).get('method', 'GET')

              # Get origin from request for CORS
              req_origin = event.get('headers', {}).get('origin', '')
              allowed_origins = [f'https://{DOMAIN}', 'http://localhost:8000']
              cors_origin = req_origin if req_origin in allowed_origins else f'https://{DOMAIN}'

              headers = {
                  'Content-Type': 'application/json',
                  'Access-Control-Allow-Origin': cors_origin,
                  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'
              }

              if method == 'OPTIONS':
                  return {'statusCode': 200, 'headers': headers, 'body': ''}

              # Helper to get IP and geolocation
              def get_ip_and_geo(event):
                  # Get IP from API Gateway HTTP API v2
                  ip = ''

                  # Try requestContext.http.sourceIp first (HTTP API v2 format)
                  request_context = event.get('requestContext', {})
                  http_context = request_context.get('http', {})
                  ip = http_context.get('sourceIp', '')

                  # Fallback to x-forwarded-for header
                  if not ip:
                      req_headers = event.get('headers') or {}
                      xff = req_headers.get('x-forwarded-for', '') or req_headers.get('X-Forwarded-For', '')
                      if xff:
                          ip = xff.split(',')[0].strip()

                  # Fallback to REST API format
                  if not ip:
                      identity = request_context.get('identity', {})
                      ip = identity.get('sourceIp', '')

                  print(f"[IP Detection] sourceIp={http_context.get('sourceIp')}, xff={event.get('headers', {}).get('x-forwarded-for')}, final_ip={ip}")

                  geo = {}
                  if ip and not ip.startswith(('10.', '172.', '192.168.', '127.')):
                      try:
                          # Use ip-api.com (free, no key needed, 45 req/min limit)
                          geo_req = urllib.request.Request(
                              f'http://ip-api.com/json/{ip}?fields=status,country,countryCode,region,regionName,city,lat,lon',
                              headers={'User-Agent': 'Foomist-Lambda'}
                          )
                          with urllib.request.urlopen(geo_req, timeout=2) as resp:
                              geo_data = json.loads(resp.read().decode('utf-8'))
                              print(f"[Geo Lookup] ip={ip}, response={geo_data}")
                              if geo_data.get('status') == 'success':
                                  geo = {
                                      'country': geo_data.get('country', ''),
                                      'countryCode': geo_data.get('countryCode', ''),
                                      'region': geo_data.get('regionName', ''),
                                      'city': geo_data.get('city', '')
                                  }
                                  # Store lat/lon as strings to avoid DynamoDB float issues
                                  if geo_data.get('lat') is not None:
                                      geo['lat'] = str(geo_data.get('lat'))
                                  if geo_data.get('lon') is not None:
                                      geo['lon'] = str(geo_data.get('lon'))
                      except Exception as e:
                          print(f"[Geo Lookup Error] ip={ip}, error={str(e)}")
                  return ip, geo

              try:
                  # ============================================
                  # ANALYTICS ENDPOINTS
                  # ============================================
                  if path in ('/analytics/event', '/t/e') and method == 'POST':
                      body = json.loads(event.get('body', '{}'))
                      table = dynamodb.Table(TABLE_NAME)

                      ip, geo = get_ip_and_geo(event)
                      now = datetime.utcnow()
                      item = {
                          'visitorId': body.get('visitorId', str(uuid.uuid4())),
                          'timestamp': now.isoformat(),
                          'createdDate': now.strftime('%Y-%m-%d'),
                          'sessionId': body.get('sessionId') or f"auto_{str(uuid.uuid4())[:8]}",
                          'sessionDuration': body.get('sessionDuration', 0),
                          'eventType': body.get('eventType', 'page_view'),
                          'eventName': body.get('eventName', ''),
                          'page': body.get('page', '/'),
                          'referrer': body.get('referrer', ''),
                          'userAgent': body.get('userAgent', ''),
                          'clientInfo': body.get('clientInfo', {}),
                          'appState': body.get('appState', {}),
                          'metadata': body.get('metadata', {}),
                          'ip': ip,
                          'geo': geo,
                          'expiresAt': int((now + timedelta(days=90)).timestamp())
                      }
                      table.put_item(Item=item)
                      return {'statusCode': 200, 'headers': headers, 'body': json.dumps({'success': True})}

                  if path in ('/analytics/batch', '/t/b') and method == 'POST':
                      body = json.loads(event.get('body', '{}'))
                      events = body.get('events', [])
                      table = dynamodb.Table(TABLE_NAME)

                      ip, geo = get_ip_and_geo(event)
                      now = datetime.utcnow()
                      with table.batch_writer() as batch:
                          for evt in events[:25]:  # Max 25 per batch
                              item = {
                                  'visitorId': evt.get('visitorId', body.get('visitorId', str(uuid.uuid4()))),
                                  'timestamp': evt.get('timestamp', now.isoformat()),
                                  'createdDate': now.strftime('%Y-%m-%d'),
                                  'sessionId': evt.get('sessionId') or body.get('sessionId') or f"auto_{str(uuid.uuid4())[:8]}",
                                  'eventType': evt.get('eventType', 'page_view'),
                                  'eventName': evt.get('eventName', ''),
                                  'page': evt.get('page', '/'),
                                  'metadata': evt.get('metadata', {}),
                                  'ip': ip,
                                  'geo': geo,
                                  'expiresAt': int((now + timedelta(days=90)).timestamp())
                              }
                              batch.put_item(Item=item)
                      return {'statusCode': 200, 'headers': headers, 'body': json.dumps({'success': True, 'count': len(events)})}

                  # ============================================
                  # ADMIN ENDPOINTS
                  # ============================================
                  if path == '/admin/login' and method == 'POST':
                      body = json.loads(event.get('body', '{}'))
                      token = create_admin_token(body.get('password', ''), body.get('rememberMe', False))
                      if token:
                          return {'statusCode': 200, 'headers': headers, 'body': json.dumps({'token': token})}
                      return {'statusCode': 401, 'headers': headers, 'body': json.dumps({'error': 'Invalid password'})}

                  if path == '/admin/analytics' and method == 'GET':
                      auth = event.get('headers', {}).get('authorization', '')
                      token = auth.replace('Bearer ', '')
                      if not verify_admin_token(token):
                          return {'statusCode': 401, 'headers': headers, 'body': json.dumps({'error': 'Unauthorized'})}

                      params = event.get('queryStringParameters', {}) or {}
                      days = int(params.get('days', 30))
                      filter_session = params.get('sessionId', '')
                      filter_ip = params.get('ip', '')
                      filter_visitor = params.get('visitorId', '')

                      table = dynamodb.Table(TABLE_NAME)
                      now = datetime.utcnow()

                      # Query last N days
                      all_events = []
                      for i in range(days):
                          date = (now - timedelta(days=i)).strftime('%Y-%m-%d')
                          resp = table.query(
                              IndexName='DateIndex',
                              KeyConditionExpression='createdDate = :d',
                              ExpressionAttributeValues={':d': date}
                          )
                          all_events.extend(resp.get('Items', []))

                      # Apply filters if specified
                      if filter_session:
                          all_events = [e for e in all_events if e.get('sessionId') == filter_session]
                      if filter_ip:
                          all_events = [e for e in all_events if e.get('ip') == filter_ip]
                      if filter_visitor:
                          all_events = [e for e in all_events if e.get('visitorId') == filter_visitor]

                      # Calculate metrics
                      unique_visitors = len(set(e['visitorId'] for e in all_events))
                      unique_sessions = len(set(e['sessionId'] for e in all_events if e.get('sessionId')))
                      unique_ips = len(set(e['ip'] for e in all_events if e.get('ip')))
                      page_views = len([e for e in all_events if e.get('eventType') == 'page_view'])

                      # Events by type
                      event_types = {}
                      for e in all_events:
                          t = e.get('eventType', 'unknown')
                          event_types[t] = event_types.get(t, 0) + 1

                      # Events by day
                      by_day = {}
                      for e in all_events:
                          d = e.get('createdDate', 'unknown')
                          by_day[d] = by_day.get(d, 0) + 1

                      # Top events
                      event_names = {}
                      for e in all_events:
                          n = e.get('eventName', '')
                          if n:
                              event_names[n] = event_names.get(n, 0) + 1
                      top_events = sorted(event_names.items(), key=lambda x: x[1], reverse=True)[:10]

                      # Sessions summary (for session picker)
                      sessions = {}
                      for e in all_events:
                          sid = e.get('sessionId', '')
                          if sid and sid not in sessions:
                              sessions[sid] = {
                                  'sessionId': sid,
                                  'visitorId': e.get('visitorId', ''),
                                  'ip': e.get('ip', ''),
                                  'geo': e.get('geo', {}),
                                  'firstSeen': e.get('timestamp', ''),
                                  'userAgent': e.get('userAgent', '')[:100],
                                  'eventCount': 0
                              }
                          if sid:
                              sessions[sid]['eventCount'] += 1
                              if e.get('timestamp', '') > sessions[sid].get('lastSeen', ''):
                                  sessions[sid]['lastSeen'] = e.get('timestamp', '')
                              if e.get('timestamp', '') < sessions[sid].get('firstSeen', 'z'):
                                  sessions[sid]['firstSeen'] = e.get('timestamp', '')

                      sessions_list = sorted(sessions.values(), key=lambda x: x.get('lastSeen', ''), reverse=True)[:100]

                      # Recent events (more detailed)
                      recent = sorted(all_events, key=lambda x: x.get('timestamp', ''), reverse=True)[:100]

                      return {
                          'statusCode': 200,
                          'headers': headers,
                          'body': json.dumps({
                              'uniqueVisitors': unique_visitors,
                              'uniqueSessions': unique_sessions,
                              'uniqueIPs': unique_ips,
                              'pageViews': page_views,
                              'totalEvents': len(all_events),
                              'eventTypes': event_types,
                              'byDay': by_day,
                              'topEvents': top_events,
                              'sessions': sessions_list,
                              'recentEvents': recent,
                              'filters': {
                                  'sessionId': filter_session,
                                  'ip': filter_ip,
                                  'visitorId': filter_visitor
                              }
                          }, cls=DecimalEncoder)
                      }

                  # ============================================
                  # SUGGESTION ENDPOINT
                  # ============================================
                  if path == '/suggest' and method == 'POST':
                      body = json.loads(event.get('body', '{}'))

                      # Validation
                      data_type = body.get('dataType', '')
                      if data_type not in ['births', 'brain', 'chips']:
                          return {'statusCode': 400, 'headers': headers, 'body': json.dumps({'error': 'Invalid dataType'})}

                      source_url = body.get('sourceUrl', '')
                      if not source_url.startswith('https://'):
                          return {'statusCode': 400, 'headers': headers, 'body': json.dumps({'error': 'URL must use HTTPS'})}

                      # Create GitHub issue
                      github_token = get_github_token()
                      owner = os.environ.get('GITHUB_OWNER', 'StefanSamne')
                      repo = os.environ.get('GITHUB_REPO', 'foomist')

                      issue_body = f"""## Data Suggestion

          ```json
          {json.dumps(body, indent=2)}
          ```

          ---
          *Submitted via foom.ist suggestion form*
          """

                      issue_data = json.dumps({
                          'title': f"[Data Suggestion] {data_type}: {body.get('sourceName', 'Unknown')}",
                          'body': issue_body,
                          'labels': ['data-suggestion']
                      }).encode('utf-8')

                      req = urllib.request.Request(
                          f'https://api.github.com/repos/{owner}/{repo}/issues',
                          data=issue_data,
                          headers={
                              'Authorization': f'Bearer {github_token}',
                              'Accept': 'application/vnd.github+json',
                              'Content-Type': 'application/json',
                              'User-Agent': 'Foomist-Lambda'
                          },
                          method='POST'
                      )

                      with urllib.request.urlopen(req) as resp:
                          result = json.loads(resp.read().decode('utf-8'))
                          return {
                              'statusCode': 200,
                              'headers': headers,
                              'body': json.dumps({
                                  'success': True,
                                  'issueNumber': result['number'],
                                  'issueUrl': result['html_url']
                              })
                          }

                  return {'statusCode': 404, 'headers': headers, 'body': json.dumps({'error': 'Not found'})}

              except Exception as e:
                  print(f"Error: {e}")  # Log for debugging
                  return {'statusCode': 500, 'headers': headers, 'body': json.dumps({'error': 'Internal server error'})}
      Tags:
        - Key: Project
          Value: foomist

  # ============================================
  # API GATEWAY
  # ============================================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: foomist-api
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - !Sub 'https://${DomainName}'
          - 'http://localhost:8000'
        AllowMethods:
          - GET
          - POST
          - OPTIONS
        AllowHeaders:
          - Content-Type
          - Authorization
        MaxAge: 86400
      Tags:
        Project: foomist

  ApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt CreateIssueLambda.Arn
      PayloadFormatVersion: '2.0'

  ApiRouteAnalyticsEvent:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /analytics/event'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiRouteAnalyticsBatch:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /analytics/batch'
      Target: !Sub 'integrations/${ApiIntegration}'

  # Short routes to avoid ad blockers
  ApiRouteTrackEvent:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /t/e'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiRouteTrackBatch:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /t/b'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiRouteAdminLogin:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /admin/login'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiRouteAdminAnalytics:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /admin/analytics'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /suggest'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: '$default'
      AutoDeploy: true
      DefaultRouteSettings:
        ThrottlingBurstLimit: 50
        ThrottlingRateLimit: 100

  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CreateIssueLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  # ============================================
  # ROUTE 53 RECORDS
  # ============================================
  DNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt CloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2  # CloudFront's fixed hosted zone ID
        EvaluateTargetHealth: false

Outputs:
  SiteBucketName:
    Value: !Ref SiteBucket
    Description: S3 bucket name for static site

  CloudFrontDomainName:
    Value: !GetAtt CloudFrontDistribution.DomainName
    Description: CloudFront distribution domain

  CloudFrontDistributionId:
    Value: !Ref CloudFrontDistribution
    Description: CloudFront distribution ID (for cache invalidation)

  ApiEndpoint:
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com'
    Description: API Gateway base endpoint

  SiteUrl:
    Value: !Sub 'https://${DomainName}'
    Description: Live site URL

  AdminPasswordSecretArn:
    Value: !Ref AdminPasswordSecret
    Description: ARN of admin password secret (retrieve with aws secretsmanager get-secret-value)
